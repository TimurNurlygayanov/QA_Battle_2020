Разбор прохождения QA Game
--------------------------

Игра QA Game доступна по адресу: https://qa.semrush-games.com/

В игре QA Game всего 7 уровней, 7ой уровень является финальным.


Первый уровень решался очень просто, достаточно было выполнить
уже готовый код:

```javascript
results = scan();
print(results.bugs);
```

На втором уровне можно было воспользоваться подсказкой и 
использовать такой код:

```javascript
result = scan();
for (bug of result.bugs) {
    fix_bug(bug);
}
```

На третьем уровне нужно было использовать уже два цикла - один цикл
для тестирования features, а второй цикл - для исправления багов:

```javascript
result = scan();
for (feature of result.features) {
    smoke_test(feature);
}
result = scan();
for (bug of result.bugs) {
    fix_bug(bug);
}
```

На четвертом уровне нужно было повторить код из третьего уровня
несколько раз, чтобы исправить блокирующие баги и довести тестирование
до конца:

```javascript
result = scan();
for (feature of result.features) {
    smoke_test(feature);
}
result = scan();
for (bug of result.bugs) {
    fix_bug(bug);
}

for (feature of result.features) {
    smoke_test(feature);
}
result = scan();
for (bug of result.bugs) {
    fix_bug(bug);
}
```

На пятом уровне нужно было отгадать путь воспроизведения бага,
это можно было сделать методом проб и ошибок, но вот простой код,
который работает:

```javascript
// Сначала делаем тестирование всех features
result = scan();
for (feature of result.features) {
    smoke_test(feature);
}

// Находим единственный на этом уровне баг
result = scan();
bug_id = result.bugs[0];

// Угадываем шаги воспроизведения (тут можно было решить ручным перебором)
let s = investigate_bug(bug_id, ">><><<");

// Исправляем баг и проходим на следующий уровень
fix_bug(bug_id);
```
Важно было так же не просто найти верные шаги воспроизведения (>><><<), но и исправить 
баг после того, как будут известны шаги его воспроизведения (до этого момента
исправить баг невозможно)

На шестом уровне отгадывать шаги для багов уже сложнее, так как багов много,
поэтому для прохождения 6го уровня нужно было написать алгоритм подбора
правильных шагов воспроизведения бага, например, такой:

```javascript
function fix_all() {
    let result = scan();
    
    for (let b of result.bugs) {
        let path = "";
        let da = 0;
       
        // В этом цикле методом перебора ищем правильные 
        // шаги воспроизведения бага:
        // Если investigate_bug возвращает 100 - значит мы подобрали
        // правильную комбинацию шагов
        while (da != 100) {
            path += ">";
            da = investigate_bug(b, path);
            if (da === 0) {
                path = path.slice(0, -1);
                path += "<";
                da = investigate_bug(b, path);
            }
        }
        
        // После того, как мы обнаружили правильную комбинацию шагов,
        // нам нужно исправить и проверифицировать баг:
        fix_bug(b);
        verify_fix(b, path);
    }
}

// Тестируем все features
result = scan();
for (let f of result.features) {
    smoke_test(f);
}

// Вызываем функцию для подбора шагов воспроизведения
// и исправления всех обнаруженных багов
fix_all();

// Повторяем эти шаги два раза, пока все баги не будут исправлены
for (let f of result.features) {
    smoke_test(f);
}
fix_all();
```

Этот алгоритм не является оптимальным, но он достаточно прост, чтобы на его примере
можно было понять логику решения задания.

И вот мы дошли до финального, 7го уровня. На этом уровне самым простым решением
будет воспользоваться алгоритмом с предыдущего, 6го уровня, и делать все то же самое,
но в бесконечном цикле:

```javascript
function fix_all() {
    let result = scan();
    
    for (let b of result.bugs) {
        let path = "";
        let da = 0;
       
        // В этом цикле методом перебора ищем правильные 
        // шаги воспроизведения бага:
        // Если investigate_bug возвращает 100 - значит мы подобрали
        // правильную комбинацию шагов
        while (da != 100) {
            path += ">";
            da = investigate_bug(b, path);
            if (da === 0) {
                path = path.slice(0, -1);
                path += "<";
                da = investigate_bug(b, path);
            }
        }
        
        // После того, как мы обнаружили правильную комбинацию шагов,
        // нам нужно исправить и проверифицировать баг:
        fix_bug(b);
        verify_fix(b, path);
    }
}

// Используем бесконечный цикл, так как алгоритм будет
// автоматически остановлен через 120 секунд:
while (true) {
    for (let f of result.features) {
        smoke_test(f);
    }
    fix_all();
}
```

Но, конечно, победить в этом непростом соревновании с таким алгоритмом бы не получилось,
так как для победы нужно было произвести дополнительные исследования и оптимизации,
о которых мы поговорим в следующем разделе "Разбор: как можно было набрать максимальное 
количество баллов?"
