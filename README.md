Введение
--------

Данный документ содержит в себе описание всех доступных функций 
для управления ZERO2 в игре QA Game.

ZERO2 полностью управляется JavaScript кодом, и, в дополнение
ко всем возможностям Java Script, он так же поддерживает 
свой собственный набор команд (SDK), который подробно 
описан в этом документе.

Игра доступна по адресу: https://qa.semrush-games.com/

Список победителей доступен по адресу https://qa.semrush-games.com/scoreboard


Функции
-------

### print(s)

Функция печатает тест или массив в консоль.
 
В качестве параметров принимает строку или массив строк.
 
Пример использования:

     print("Hello, world!");


### scan()

Функция scan позволяет обнаруживать все доступные для 
тестирования фичи и баги, которые были найдены в процессе 
тестирования. В результате выполнения функции на экран будет
выведена информация о количестве найденных features и багов.
 
scan() возвращает объект, содержащий в себе список всех 
features и bugs.
 
Пример использования:

    results = scan();
    print(results.features);
    print(results.bugs);

Начиная с 6го уровня функция scan так же возвращает 
список багов, которые были исправлены и должны быть
проверифицированы:

    result = scan();
    print(result.to_verify);


### fix_bug(bug_id)

Функция fix_bug пробует исправить баг (это получается не 
всегда).
  
fix_bug принимает в качестве аргумента идентификатор бага,
например “37D2CD90-A8F3-4707-B656-7D68367AA9CE”
(идентификаторы найденных багов можно получить 
с помощью функции scan).
 
Функция возвращает 0, если баг не был исправлен, и 1, 
если баг был исправлен.
 
Внимание: исправление бага может повлечь за собой появление 
новых багов.
 
Пример использования:
 
    fix_bug("37D2CD90-A8F3-4707-B656-7D68367AA9CE");
 
Можно исправить все найденные баги, используя цикл:
 
    results = scan();
    for (bug of results.bugs) {
        fix_bug(bug);
    }

это можно сделать и другим способом:
 
    results = scan();
    results.bugs.forEach(fix_bug);


### smoke_test(feature_id)

Функция smoke_test позволяет провести быстрое тестирование
указанной в качестве аргумента feature.
 
smoke_test принимает в качестве аргумента идентификатор
feature (идентификатор feature можно получить с помощью 
функции scan).
 
Выполнение функции smoke_test может быть прервано, если в 
процессе тестирования был обнаружен блокирующий тестирование
баг. В этом случае features не может быть полностью 
протестирована до тех пор, пока не будут исправлены 
все обнаруженные дефекты.
 
Данная функция возвращает 0, если найден блокирующий 
тестирование баг и тестирование было прервано, и 1, 
если тестирование завершено успешно.
 
Пример использования:
 
    smoke_test("feature_7E06FA37-D5EC-4914-9601-D7DAC1EEF074");
 
Можно сразу протестировать все доступные features, 
используя цикл:
 
    results = scan();
    for (feature of results.features) {
        smoke_test(feature);
    }
    
то же самое можно сделать другим способом:
 
    results = scan();
    results.features.forEach(smoke_test);
 
 
### investigate_bug(bug_id, ">><>")

Функция investigate_bug позволяет исследовать баг
для того, чтобы найти точные шаги воспроизведения.
Поиск правильных шагов воспроиведения итеративный,
необходимо вызвать функцию investigate_bug несколько
раз с различными значениями аргументов для того,
чтобы исследовать найденный баг.
 
После того, как будут известны точные шаги воспроизведения,
баг становится доступен для исправления и верификации.
 
В качестве параметров данная функция принимает два значения:
 
  * bug_id - идентификатор бага
  * path - строка, состоящая из символов ">" и "<", и 
    содержащая "путь воспроизведения" для данного дефекта.
 
В случае, если параметр path содержит правильную, но 
не полную комбинацию шагов, функция возвращает 1,
если комбинация неверная, функция возвращает 0.
Если в path указана полная правильная комбинация шагов,
то функция возвращает 100.
 
Параметр path может содержать только часть 
"пути воспроизведения" бага, например, если полный
правильный ответ равен ">><<", то:
 
    investigate_bug(bug_id, ">") == 1
    investigate_bug(bug_id, ">>") == 1
    investigate_bug(bug_id, ">>>") == 0
    investigate_bug(bug_id, ">><") == 1
    investigate_bug(bug_id, ">><>") == 0
    investigate_bug(bug_id, ">><<") == 100

После того, как функция investigate_bug вернет 100, можно
вызывать функцию fix_bug для данного бага, так как мы
знаем точные шаги воспроизведения и можем его исправить.


### verify_fix(bug_id, ">><>")

Функция verify_fix позволяет верифицировать исправление 
бага, убедившись в том, что баг действительно исправлен,
и получить дополнительные очки за его исправление.

В качестве параметров данная функция принимает два значения:
 
  * bug_id - идентификатор бага
  * path - строка, состоящая из символов ">" и "<", и 
    содержащая "путь воспроизведения" для данного дефекта.

Если в path указана полная правильная комбинация шагов, и баг
действительно был исправлен, функция возвращает 100.
Если баг не был исправлен, или для верификации бага использовались 
неправильные шаги воспроизведения, исправление бага остается
неверефицированным и функция возвращает 0.

Пример верификации бага:

    investigate_bug(bug_id, ">") == 1
    investigate_bug(bug_id, ">>") == 0
    investigate_bug(bug_id, "><") == 100
    
    // Прежде чем верифицировать исправление, баг 
    // нужно исправить
    verify_fix(bug_id, "><") == 0
    
    fix_bug(bug_id);
    
    // Если указать неверные шаги воспроизведения, 
    // то верификация не произойдет
    verify_fix(bug_id, ">") == 0
    
    // Баг исправлен, указаны верные шаги воспроизведения, 
    // исправление верифицировано успешно
    verify_fix(bug_id, "><") == 100

После верификации бага вы получаете максимальное количество 
очков за этот баг.

Если баг был исправлен, но идентификатор бага утерян,
список багов, доступных для верификации, можно получить
с помощью функции scan():

    result = scan();
    print(result.to_verify);


Советы по прохождению игры
--------------------------
Эти советы помогут тебе пройти все уровни быстрее и набрать
максимальное количество баллов:
1) Для прохождения игры лучше использовать компьютер с 
полноценной клавиатурой и браузером Chrome (мы не тестировали
игру в других браузерах)
2) Перед выполнением кода на любом уровне сохраняй код на
своем компьютере, это позволит восстановить код, даже если 
что-то пойдет не так (возникнет ошибка или страница с игрой
будет закрыта). Код с предыдущих уровней может пригодиться
на более сложных уровнях.
3) Не пытайтесь "обхитрить" игру. Выполняя все задания по 
порядку, вы сможете лучше подготовиться к финальному уровню 
и набрать максимальное количество очков.
4) На финальном уровне следи за количеством оставшихся 
попыток, не запускай код, если не уверен в том, что он
работает правильно и быстро. Старайся не делать лишних 
операций, каждая лишняя опреация отнимает ценное время.
5) Во время выполнения алгоритма интерфейс игры может 
зависнуть (особенно, если написанный JavaScript код будет 
выполнять бесконечный цикл), в случае, если страница не 
отвечает слишком долго, мы рекомендуем открыть эту
же страницу в новой вкладке браузера, а старую страницу 
закрыть.


Правила финального уровня
-------------------------
1) Нажать кнопку RUN можно только 60 раз (то есть у тебя 
есть 60 попыток, чтобы набрать максимальное число баллов)
2) 120 секунд выделяется для того, чтобы твой алгоритм нашел
и обезвредил максимальное количество багов. Через 120 секунд
после нажатия на кнопку RUN алгоритм автоматически 
завершается (вызывая исключение) 
и баллы за исправление дефектов больше не засчитываются.
3) За каждый исправленный баг игроки получают 100 очков, 
за исправленный и верифицированный баг - 150 очков
4) Каждый раз при нажатии кнопки RUN все очки сбрасываются, 
и новые баги генерируются случайным образом. В таблицу 
победителей записывается твой лучший результат за 60ть 
попыток


Разбор: как дойди до финального уровня?
---------------------------------------

Первый уровень решался очень просто, достаточно было выполнить
уже готовый код:

```javascript
results = scan();
print(results.bugs);
```

На втором уровне можно было воспользоваться подсказкой и 
использовать такой код:

```javascript
result = scan();
for (bug of result.bugs) {
    fix_bug(bug);
}
```

На третьем уровне нужно было использовать уже два цикла - один цикл
для тестирования features, а второй цикл - для исправления багов:

```javascript
result = scan();
for (feature of result.features) {
    smoke_test(feature);
}
result = scan();
for (bug of result.bugs) {
    fix_bug(bug);
}
```

На четвертом уровне нужно было повторить код из третьего уровня
несколько раз, чтобы исправить блокирующие баги и довести тестирование
до конца:

```javascript
result = scan();
for (feature of result.features) {
    smoke_test(feature);
}
result = scan();
for (bug of result.bugs) {
    fix_bug(bug);
}

for (feature of result.features) {
    smoke_test(feature);
}
result = scan();
for (bug of result.bugs) {
    fix_bug(bug);
}
```

На пятом уровне нужно было отгадать путь воспроизведения бага,
это можно было сделать методом проб и ошибок, но вот простой код,
который работает:

```javascript
// Сначала делаем тестирование всех features
result = scan();
for (feature of result.features) {
    smoke_test(feature);
}

// Находим единственный на этом уровне баг
result = scan();
bug_id = result.bugs[0];

// Угадываем шаги воспроизведения (тут можно было решить ручным перебором)
let s = investigate_bug(bug_id, ">><><<");

// Исправляем баг и проходим на следующий уровень
fix_bug(bug_id);
```
Важно было так же не просто найти верные шаги воспроизведения (>><><<), но и исправить 
баг после того, как будут известны шаги его воспроизведения (до этого момента
исправить баг невозможно)

На шестом уровне отгадывать шаги для багов уже сложнее, так как багов много,
поэтому для прохождения 6го уровня нужно было написать алгоритм подбора
правильных шагов воспроизведения бага, например, такой:

```javascript
function fix_all() {
    let result = scan();
    
    for (let b of result.bugs) {
        let path = "";
        let da = 0;
       
        // В этом цикле методом перебора ищем правильные 
        // шаги воспроизведения бага:
        // Если investigate_bug возвращает 100 - значит мы подобрали
        // правильную комбинацию шагов
        while (da != 100) {
            path += ">";
            da = investigate_bug(b, path);
            if (da === 0) {
                path = path.slice(0, -1);
                path += "<";
                da = investigate_bug(b, path);
            }
        }
        
        // После того, как мы обнаружили правильную комбинацию шагов,
        // нам нужно исправить и проверифицировать баг:
        fix_bug(b);
        verify_fix(b, path);
    }
}

// Тестируем все features
result = scan();
for (let f of result.features) {
    smoke_test(f);
}

// Вызываем функцию для подбора шагов воспроизведения
// и исправления всех обнаруженных багов
fix_all();

// Повторяем эти шаги два раза, пока все баги не будут исправлены
for (let f of result.features) {
    smoke_test(f);
}
fix_all();
```

Этот алгоритм не является оптимальным, но он достаточно прост, чтобы на его примере
можно было понять логику решения задания.

И вот мы дошли до финального, 7го уровня. На этом уровне самым простым решением
будет воспользоваться алгоритмом с предыдущего, 6го уровня, и делать все то же самое,
но в бесконечном цикле:

```javascript
function fix_all() {
    let result = scan();
    
    for (let b of result.bugs) {
        let path = "";
        let da = 0;
       
        // В этом цикле методом перебора ищем правильные 
        // шаги воспроизведения бага:
        // Если investigate_bug возвращает 100 - значит мы подобрали
        // правильную комбинацию шагов
        while (da != 100) {
            path += ">";
            da = investigate_bug(b, path);
            if (da === 0) {
                path = path.slice(0, -1);
                path += "<";
                da = investigate_bug(b, path);
            }
        }
        
        // После того, как мы обнаружили правильную комбинацию шагов,
        // нам нужно исправить и проверифицировать баг:
        fix_bug(b);
        verify_fix(b, path);
    }
}

// Используем бесконечный цикл, так как алгоритм будет
// автоматически остановлен через 120 секунд:
while (true) {
    for (let f of result.features) {
        smoke_test(f);
    }
    fix_all();
}
```

Но, конечно, победить в этом непростом соревновании с таким алгоритмом бы не получилось,
так как для победы нужно было произвести дополнительные исследования и оптимизации,
о которых мы поговорим в следующем разделе "Разбор: как можно было набрать максимальное 
количество баллов?"


Разбор: как можно было набрать максимальное количество баллов?
--------------------------------------------------------------


Лучшие решения
--------------

Здесь мы добавим разбор самых интересных решений 
для последнего уровня, которые будут использованы участниками
QA Game на конференции Heisenbug 2020.