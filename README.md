Введение
--------

Данный документ содержит в себе описание всех доступных функций 
для управления ZERO2 в игре QA Game.

ZERO2 полностью управляется JavaScript кодом, и, в дополнение
ко всем возможностям Java Script, он так же поддерживает 
свой собственный набор команд (SDK), который подробно 
описан в этом документе.

Игра доступна по адресу: https://qa.semrush-games.com/

Список победителей доступен по адресу https://qa.semrush-games.com/scoreboard


Функции
-------

### print(s)

Функция печатает тест или массив в консоль.
 
В качестве параметров принимает строку или массив строк.
 
Пример использования:

     print("Hello, world!");


### scan()

Функция scan позволяет обнаруживать все доступные для 
тестирования фичи и баги, которые были найдены в процессе 
тестирования. В результате выполнения функции на экран будет
выведена информация о количестве найденных features и багов.
 
scan() возвращает объект, содержащий в себе список всех 
features и bugs.
 
Пример использования:

    results = scan();
    print(results.features);
    print(results.bugs);

Начиная с 6го уровня функция scan так же возвращает 
список багов, которые были исправлены и должны быть
проверифицированы:

    result = scan();
    print(result.to_verify);


### fix_bug(bug_id)

Функция fix_bug пробует исправить баг (это получается не 
всегда).
  
fix_bug принимает в качестве аргумента идентификатор бага,
например “37D2CD90-A8F3-4707-B656-7D68367AA9CE”
(идентификаторы найденных багов можно получить 
с помощью функции scan).
 
Функция возвращает 0, если баг не был исправлен, и 1, 
если баг был исправлен.
 
Внимание: исправление бага может повлечь за собой появление 
новых багов.
 
Пример использования:
 
    fix_bug("37D2CD90-A8F3-4707-B656-7D68367AA9CE");
 
Можно исправить все найденные баги, используя цикл:
 
    results = scan();
    for (bug of results.bugs) {
        fix_bug(bug);
    }

это можно сделать и другим способом:
 
    results = scan();
    results.bugs.forEach(fix_bug);


### smoke_test(feature_id)

Функция smoke_test позволяет провести быстрое тестирование
указанной в качестве аргумента feature.
 
smoke_test принимает в качестве аргумента идентификатор
feature (идентификатор feature можно получить с помощью 
функции scan).
 
Выполнение функции smoke_test может быть прервано, если в 
процессе тестирования был обнаружен блокирующий тестирование
баг. В этом случае features не может быть полностью 
протестирована до тех пор, пока не будут исправлены 
все обнаруженные дефекты.
 
Данная функция возвращает 0, если найден блокирующий 
тестирование баг и тестирование было прервано, и 1, 
если тестирование завершено успешно.
 
Пример использования:
 
    smoke_test("feature_7E06FA37-D5EC-4914-9601-D7DAC1EEF074");
 
Можно сразу протестировать все доступные features, 
используя цикл:
 
    results = scan();
    for (feature of results.features) {
        smoke_test(feature);
    }
    
то же самое можно сделать другим способом:
 
    results = scan();
    results.features.forEach(smoke_test);
 
 
### investigate_bug(bug_id, ">><>")

Функция investigate_bug позволяет исследовать баг
для того, чтобы найти точные шаги воспроизведения.
Поиск правильных шагов воспроиведения итеративный,
необходимо вызвать функцию investigate_bug несколько
раз с различными значениями аргументов для того,
чтобы исследовать найденный баг.
 
После того, как будут известны точные шаги воспроизведения,
баг становится доступен для исправления и верификации.
 
В качестве параметров данная функция принимает два значения:
 
  * bug_id - идентификатор бага
  * path - строка, состоящая из символов ">" и "<", и 
    содержащая "путь воспроизведения" для данного дефекта.
 
В случае, если параметр path содержит правильную, но 
не полную комбинацию шагов, функция возвращает 1,
если комбинация неверная, функция возвращает 0.
Если в path указана полная правильная комбинация шагов,
то функция возвращает 100.
 
Параметр path может содержать только часть 
"пути воспроизведения" бага, например, если полный
правильный ответ равен ">><<", то:
 
    investigate_bug(bug_id, ">") == 1
    investigate_bug(bug_id, ">>") == 1
    investigate_bug(bug_id, ">>>") == 0
    investigate_bug(bug_id, ">><") == 1
    investigate_bug(bug_id, ">><>") == 0
    investigate_bug(bug_id, ">><<") == 100

После того, как функция investigate_bug вернет 100, можно
вызывать функцию fix_bug для данного бага, так как мы
знаем точные шаги воспроизведения и можем его исправить.


### verify_fix(bug_id, ">><>")

Функция verify_fix позволяет верифицировать исправление 
бага, убедившись в том, что баг действительно исправлен,
и получить дополнительные очки за его исправление.

В качестве параметров данная функция принимает два значения:
 
  * bug_id - идентификатор бага
  * path - строка, состоящая из символов ">" и "<", и 
    содержащая "путь воспроизведения" для данного дефекта.

Если в path указана полная правильная комбинация шагов, и баг
действительно был исправлен, функция возвращает 100.
Если баг не был исправлен, или для верификации бага использовались 
неправильные шаги воспроизведения, исправление бага остается
неверефицированным и функция возвращает 0.

Пример верификации бага:

    investigate_bug(bug_id, ">") == 1
    investigate_bug(bug_id, ">>") == 0
    investigate_bug(bug_id, "><") == 100
    
    // Прежде чем верифицировать исправление, баг 
    // нужно исправить
    verify_fix(bug_id, "><") == 0
    
    fix_bug(bug_id);
    
    // Если указать неверные шаги воспроизведения, 
    // то верификация не произойдет
    verify_fix(bug_id, ">") == 0
    
    // Баг исправлен, указаны верные шаги воспроизведения, 
    // исправление верифицировано успешно
    verify_fix(bug_id, "><") == 100

После верификации бага вы получаете максимальное количество 
очков за этот баг.

Если баг был исправлен, но идентификатор бага утерян,
список багов, доступных для верификации, можно получить
с помощью функции scan():

    result = scan();
    print(result.to_verify);


Советы по прохождению игры
--------------------------
Эти советы помогут тебе пройти все уровни быстрее и набрать
максимальное количество баллов:
1) Для прохождения игры лучше использовать компьютер с 
полноценной клавиатурой и браузером Chrome (мы не тестировали
игру в других браузерах)
2) Перед выполнением кода на любом уровне сохраняй код на
своем компьютере, это позволит восстановить код, даже если 
что-то пойдет не так (возникнет ошибка или страница с игрой
будет закрыта). Код с предыдущих уровней может пригодиться
на более сложных уровнях.
3) Не пытайтесь "обхитрить" игру. Выполняя все задания по 
порядку, вы сможете лучше подготовиться к финальному уровню 
и набрать максимальное количество очков.
4) На финальном уровне следи за количеством оставшихся 
попыток, не запускай код, если не уверен в том, что он
работает правильно и быстро. Старайся не делать лишних 
операций, каждая лишняя опреация отнимает ценное время.
5) Во время выполнения алгоритма интерфейс игры может 
зависнуть (особенно, если написанный JavaScript код будет 
выполнять бесконечный цикл), в случае, если страница не 
отвечает слишком долго, мы рекомендуем открыть эту
же страницу в новой вкладке браузера, а старую страницу 
закрыть.


Правила финального уровня
-------------------------
1) Нажать кнопку RUN можно только 30 раз (то есть у тебя 
есть 30 попыток, чтобы набрать максимальное число баллов)
2) 120 секунд выделяется для того, чтобы твой алгоритм нашел
и обезвредил максимальное количество багов. Через 120 секунд
после нажатия на кнопку RUN алгоритм автоматически 
завершается (вызывая исключение) 
и баллы за исправление дефектов больше не засчитываются.
3) За каждый исправленный баг игроки получают 100 очков, 
за исправленный и верифицированный баг - 150 очков
4) Каждый раз при нажатии кнопки RUN все очки сбрасываются, 
и новые баги генерируются случайным образом. В таблицу 
победителей записывается твой лучший результат за 30ть 
попыток


Лучшие решения
--------------

Здесь мы добавим разбор самых интересных решений 
для последнего уровня, которые будут использованы участниками
QA Game на конференции Heisenbug 2020.